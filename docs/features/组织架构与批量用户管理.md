# 组织架构与批量用户管理 - 技术设计文档 (最终执行版)

## 文档信息

- **功能名称**: 组织架构与批量用户管理
- **版本**: v3.0 (Linus重构版)
- **审核状态**: **已批准并重构 (Refactored by Linus)**
- **核心原则**: 数据结构优先，**真正消除特殊情况**，实用主义，零破坏性。
- **重构要点**: 移除所有冗余字段，统一聚合表设计，简化复杂度。

---

## 1. 需求概述

### 1.1 核心需求

1. **组织树形结构**: 支持多层级组织架构 (公司 > 部门 > 小组)。
2. **批量用户创建**: 管理员可批量创建10万级别用户并分配到指定组织。
3. **组织维度统计**: 按组织维度统计用户在线数据。

### 1.2 MVP范围

✅ **包含功能**:

- 系统管理员权限 (复用现有 `is_superuser`)。
- 组织CRUD和树形查询。
- 批量用户创建 (后台异步任务)。
- 组织维度在线统计。
- 统计Dashboard API。

❌ **不包含(可后续扩展)**:

- 组织管理员角色。
- 任务实时进度推送。

---

## 2. 架构设计

### 2.1 技术选型

| 组件 | 技术方案 | 理由 |
| --- | --- | --- |
| 组织树存储 | PostgreSQL `ltree` | 成熟、高效，专为树形结构设计。 |
| 树形索引 | `GIST (siglen=100)` | 官方推荐，性能优越。 |
| 批量任务 | `tokio::spawn` | 低频操作，简单直接，避免过度设计。 |
| 在线追踪 | Redis (复用现有) | `presence_manager` 已存在，逻辑不变。 |
| **统计聚合** | **PostgreSQL (统一维度表)** | **核心原则：一张表处理所有维度（房间、组织、用户）。消除重复schema，未来扩展无需新表。** |

### 2.2 数据流架构

```
┌─────────────────────────────────────────────────────────────┐
│                     管理员操作层                              │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐      │
│  │ 组织管理API   │  │ 批量导入API   │  │ 统计查询API   │      │
│  └──────┬───────┘  └──────┬───────┘  └──────┬───────┘      │
└─────────┼──────────────────┼──────────────────┼─────────────┘
          │                  │                  │
          ▼                  ▼                  ▼
┌─────────────────────────────────────────────────────────────┐
│                    Application层                             │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐      │
│  │OrgRepository │  │BulkUserService│  │OrgStatsService│     │
│  └──────┬───────┘  └──────┬───────┘  └──────┬───────┘      │
└─────────┼──────────────────┼──────────────────┼─────────────┘
          │                  │                  │
          ▼                  ▼                  ▼
┌─────────────────────────────────────────────────────────────┐
│                  Infrastructure层                            │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐      │
│  │ PostgreSQL   │  │  AsyncTask   │  │StatsAggregator│      │
│  │  (ltree)     │  │  (tokio)     │  │ (统一维度表)   │      │
│  └──────────────┘  └──────────────┘  └──────────────┘      │
└─────────────────────────────────────────────────────────────┘
```

**数据流说明**: 管理员通过API操作组织和用户 -> Application层的服务处理业务逻辑 -> `tokio::spawn` 处理批量任务 -> `presence_events` 记录原始数据（**新增 `org_path`**） -> `StatsAggregator` 读取原始事件，写入 **统一的 `stats_aggregated` 表**（通过 `dimension_type` 区分房间/组织维度） -> API层从统一聚合表中按维度查询数据。

---

## 3. 数据库设计

**核心原则：只允许增加新表或为现有表增加安全的列。绝不执行锁表的 `ALTER` 操作。**

### 3.1 Migration顺序 (最终安全版)

```
migrations/
├── ... (现有迁移)
├── 0005_organizations.sql            (新增 - 组织表，简化schema)
├── 0006_users_org_fields.sql         (新增 - 用户组织字段，仅org_id)
├── 0007_rooms_org_fields.sql         (新增 - 聊天室组织字段)
├── 0008_presence_events_org_path.sql (新增 - 为事件增加org_path)
├── 0009_bulk_tasks.sql               (新增 - 批量任务表)
└── 0010_stats_aggregated_refactor.sql (重构 - 统一维度表)
```

### 3.2 迁移文件内容

#### `migrations/0005_organizations.sql`

```sql
-- 启用ltree扩展
CREATE EXTENSION IF NOT EXISTS ltree;

-- 组织表 - 树形结构 (简化版，移除冗余字段)
CREATE TABLE organizations (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name TEXT NOT NULL,
    path LTREE NOT NULL UNIQUE,  -- 唯一的真相来源，parent_id和level都可从此派生
    metadata JSONB,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- GIST索引用于高效树形查询
CREATE INDEX org_path_gist_idx ON organizations USING GIST(path gist_ltree_ops(siglen=100));

COMMENT ON TABLE organizations IS '组织架构树形表(使用ltree实现,path是唯一真相来源)';
COMMENT ON COLUMN organizations.path IS 'ltree路径,所有树形信息的唯一来源(level/parent可派生)';
```

#### `migrations/0006_users_org_fields.sql`

```sql
-- 用户表增加组织字段 (仅org_id，移除冗余的org_path)
ALTER TABLE users
    ADD COLUMN IF NOT EXISTS org_id UUID REFERENCES organizations(id) ON DELETE SET NULL;

-- 索引用于JOIN查询
CREATE INDEX IF NOT EXISTS users_org_id_idx ON users(org_id);

COMMENT ON COLUMN users.org_id IS '所属组织ID,通过JOIN organizations获取org_path';
```

**设计说明**: 移除了 `org_path` 冗余列。org_path通过JOIN查询获取：
```sql
SELECT u.*, o.path as org_path
FROM users u
LEFT JOIN organizations o ON u.org_id = o.id;
```
避免了组织重命名时的级联更新问题，保持数据一致性。

#### `migrations/0007_rooms_org_fields.sql`

```sql
-- 聊天室表增加组织字段
ALTER TABLE chat_rooms
    ADD COLUMN IF NOT EXISTS org_id UUID REFERENCES organizations(id) ON DELETE SET NULL,
    ADD COLUMN IF NOT EXISTS is_org_visible BOOLEAN DEFAULT FALSE;
CREATE INDEX IF NOT EXISTS chat_rooms_org_id_idx ON chat_rooms(org_id);
COMMENT ON COLUMN chat_rooms.org_id IS '所属组织ID(可选)';
```

#### `migrations/0008_presence_events_org_path.sql`

```sql
-- 为原始事件增加组织路径，这是聚合查询的数据来源
ALTER TABLE presence_events
    ADD COLUMN IF NOT EXISTS org_path LTREE;
CREATE INDEX IF NOT EXISTS presence_events_org_path_gist_idx ON presence_events
    USING GIST(org_path gist_ltree_ops(siglen=100));
COMMENT ON COLUMN presence_events.org_path IS '事件发生时的组织路径，用于树形聚合';
```

#### `migrations/0009_bulk_tasks.sql`

```sql
-- 批量任务状态跟踪表
CREATE TABLE bulk_tasks (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    task_type TEXT NOT NULL,
    status TEXT NOT NULL DEFAULT 'pending',
    created_by UUID NOT NULL REFERENCES users(id),
    total_count INT NOT NULL,
    processed_count INT NOT NULL DEFAULT 0,
    success_count INT NOT NULL DEFAULT 0,
    failed_count INT NOT NULL DEFAULT 0,
    error_message TEXT,
    result_data JSONB,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    started_at TIMESTAMPTZ,
    completed_at TIMESTAMPTZ,
    CONSTRAINT valid_status CHECK (status IN ('pending', 'processing', 'completed', 'failed'))
);
CREATE INDEX bulk_tasks_status_idx ON bulk_tasks(status);
COMMENT ON TABLE bulk_tasks IS '批量任务状态跟踪表';
```

#### `migrations/0010_stats_aggregated_refactor.sql`

```sql
-- 统一维度表设计：一张表处理所有维度（房间、组织、用户等）
-- 假设原有 stats_aggregated 表只有 room_id，现在需要重构为多维度表

-- 1. 创建新的统一维度表
CREATE TABLE stats_aggregated_v2 (
    dimension_type TEXT NOT NULL,  -- 'room' | 'org' | 'user' | ...
    dimension_id UUID NOT NULL,
    time_bucket TIMESTAMPTZ NOT NULL,
    granularity time_granularity NOT NULL,
    peak_online_count BIGINT NOT NULL DEFAULT 0,
    avg_online_count DOUBLE PRECISION NOT NULL DEFAULT 0,
    total_connections BIGINT NOT NULL DEFAULT 0,
    unique_users BIGINT NOT NULL DEFAULT 0,
    avg_session_duration DOUBLE PRECISION NOT NULL DEFAULT 0,
    PRIMARY KEY (dimension_type, dimension_id, time_bucket, granularity)
);

-- 复合索引用于按维度和时间查询
CREATE INDEX idx_stats_dimension_time ON stats_aggregated_v2
    (dimension_type, time_bucket, granularity);

-- 单独的时间索引用于时间范围查询
CREATE INDEX idx_stats_time_bucket ON stats_aggregated_v2 (time_bucket);

COMMENT ON TABLE stats_aggregated_v2 IS '统一维度统计表,通过dimension_type区分不同维度';
COMMENT ON COLUMN stats_aggregated_v2.dimension_type IS '维度类型: room(房间) org(组织) user(用户)等';
COMMENT ON COLUMN stats_aggregated_v2.dimension_id IS '维度实体ID';

-- 2. 迁移现有数据（如果 stats_aggregated 表已存在）
-- INSERT INTO stats_aggregated_v2
--     (dimension_type, dimension_id, time_bucket, granularity,
--      peak_online_count, avg_online_count, total_connections, unique_users, avg_session_duration)
-- SELECT
--     'room'::TEXT,
--     room_id,
--     time_bucket,
--     granularity,
--     peak_online_count,
--     avg_online_count,
--     total_connections,
--     unique_users,
--     avg_session_duration
-- FROM stats_aggregated;

-- 3. 重命名表（在确认数据迁移无误后）
-- DROP TABLE stats_aggregated;
-- ALTER TABLE stats_aggregated_v2 RENAME TO stats_aggregated;
```

**设计优势**:
1. **消除重复**: 一张表，一套聚合逻辑，未来增加新维度无需新表
2. **性能无损**: 复合主键和索引确保查询性能与分表方案相当
3. **扩展性强**: 增加 'user' 维度只需插入数据，不需要schema变更
4. **代码简化**: 聚合服务统一处理，避免维护多套相似逻辑

---

## 4. Domain层设计

### 4.1 Organization实体

```rust
// crates/domain/src/organization.rs

use crate::value_objects::{OrgId, OrgPath, Timestamp};
use crate::errors::DomainError;

/// 组织节点（简化版：移除冗余字段）
#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize)]
pub struct Organization {
    pub id: OrgId,
    pub name: String,
    pub path: OrgPath,  // 'root.sales.east' - 唯一真相来源
    pub metadata: Option<serde_json::Value>,
    pub created_at: Timestamp,
    pub updated_at: Timestamp,
}

impl Organization {
    /// 创建组织节点（统一构造函数，消除根节点/子节点特殊情况）
    pub fn new(
        id: OrgId,
        name: impl Into<String>,
        parent_path: Option<&OrgPath>,  // None表示根节点
        now: Timestamp,
    ) -> Result<Self, DomainError> {
        let name = Self::validate_name(name.into())?;
        let path = match parent_path {
            Some(parent) => parent.append(name.to_lowercase())?,
            None => OrgPath::root(name.to_lowercase()),
        };

        Ok(Self {
            id,
            name,
            path,
            metadata: None,
            created_at: now,
            updated_at: now,
        })
    }

    /// 重命名组织(会影响path)
    pub fn rename(&mut self, name: impl Into<String>, now: Timestamp) -> Result<(), DomainError> {
        let name = Self::validate_name(name.into())?;
        self.name = name;
        // Note: path更新需要在Repository层处理(涉及级联更新子节点)
        self.updated_at = now;
        Ok(())
    }

    /// 验证组织名称
    fn validate_name(name: String) -> Result<String, DomainError> {
        let trimmed = name.trim();
        if trimmed.is_empty() {
            return Err(DomainError::invalid_argument("org_name", "不能为空"));
        }
        if trimmed.len() > 100 {
            return Err(DomainError::invalid_argument("org_name", "长度不能超过100"));
        }
        // ltree要求path只能包含字母数字下划线
        if !trimmed.chars().all(|c| c.is_alphanumeric() || c == '_' || c == '-' || c.is_whitespace()) {
            return Err(DomainError::invalid_argument("org_name", "只能包含字母数字下划线和空格"));
        }
        Ok(trimmed.to_owned())
    }

    /// 检查是否是根节点（从path派生）
    pub fn is_root(&self) -> bool {
        self.path.level() == 0
    }

    /// 获取层级（从path派生）
    pub fn level(&self) -> i32 {
        self.path.level()
    }

    /// 获取父路径（从path派生）
    pub fn parent_path(&self) -> Option<OrgPath> {
        self.path.parent()
    }

    /// 检查是否是指定组织的祖先
    pub fn is_ancestor_of(&self, other: &Organization) -> bool {
        other.path.is_descendant_of(&self.path)
    }

    /// 检查是否是指定组织的后代
    pub fn is_descendant_of(&self, other: &Organization) -> bool {
        self.path.is_descendant_of(&other.path)
    }
}
```

**设计改进**:
1. **消除特殊情况**: 不再有 `new_root()` vs `new_child()`，统一为 `new()`
2. **移除冗余**: parent_id 和 level 从 path 派生，提供方法访问
3. **简化逻辑**: 根节点判断变为 `path.level() == 0`，无需检查 parent_id

### 4.2 值对象扩展

```rust
// crates/domain/src/value_objects.rs

use std::fmt;

/// 组织ID
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]
pub struct OrgId(uuid::Uuid);

impl OrgId {
    pub fn new() -> Self {
        Self(uuid::Uuid::new_v4())
    }

    pub fn from(id: uuid::Uuid) -> Self {
        Self(id)
    }
}

impl From<OrgId> for uuid::Uuid {
    fn from(id: OrgId) -> Self {
        id.0
    }
}

/// 组织路径(ltree格式)
#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize)]
pub struct OrgPath(String);

impl OrgPath {
    /// 创建根路径
    pub fn root(name: impl Into<String>) -> Self {
        Self(name.into())
    }

    /// 从字符串解析路径
    pub fn parse(path: impl Into<String>) -> Result<Self, DomainError> {
        let path = path.into();
        // 验证ltree格式: 只能包含字母数字下划线和点
        if !path.chars().all(|c| c.is_alphanumeric() || c == '_' || c == '.') {
            return Err(DomainError::invalid_argument("org_path", "格式不正确"));
        }
        Ok(Self(path))
    }

    /// 追加子节点
    pub fn append(&self, child: impl Into<String>) -> Result<Self, DomainError> {
        let child = child.into();
        Ok(Self(format!("{}.{}", self.0, child)))
    }

    /// 检查是否是指定路径的后代
    pub fn is_descendant_of(&self, ancestor: &OrgPath) -> bool {
        self.0.starts_with(&format!("{}.", ancestor.0))
    }

    /// 获取父路径
    pub fn parent(&self) -> Option<Self> {
        self.0.rfind('.').map(|pos| Self(self.0[..pos].to_owned()))
    }

    /// 获取层级
    pub fn level(&self) -> i32 {
        self.0.matches('.').count() as i32
    }
}

impl fmt::Display for OrgPath {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}", self.0)
    }
}

impl From<OrgPath> for String {
    fn from(path: OrgPath) -> Self {
        path.0
    }
}
```

### 4.3 User实体扩展

```rust
// crates/domain/src/user.rs

// 在现有User结构体中增加字段（简化版：仅org_id）
pub struct User {
    // ... 现有字段 ...

    // 新增组织字段（仅引用，不冗余path）
    pub org_id: Option<OrgId>,
}

impl User {
    /// 分配到组织
    pub fn assign_to_org(&mut self, org_id: OrgId, now: Timestamp) {
        self.org_id = Some(org_id);
        self.updated_at = now;
    }

    /// 移除组织关联
    pub fn remove_from_org(&mut self, now: Timestamp) {
        self.org_id = None;
        self.updated_at = now;
    }
}
```

**设计改进**:
1. **移除冗余**: 不再存储 `org_path`，通过 Repository 层 JOIN 查询获取
2. **数据一致性**: 组织重命名不需要级联更新所有用户
3. **查询方式**: 需要 org_path 时通过 `UserRepository::find_with_org(user_id)` 获取

---

## 5. Application层设计

### 5.1 `StatsAggregator` 重构

统一聚合服务，处理所有维度的统计数据：

```rust
pub struct StatsAggregator {
    stats_repo: Arc<dyn StatsRepository>,
    org_repo: Arc<dyn OrgRepository>,
}

impl StatsAggregator {
    /// 统一的聚合方法，处理所有维度
    pub async fn aggregate(&self, time_range: TimeRange) -> Result<()> {
        // 1. 聚合房间维度
        self.aggregate_dimension("room", time_range).await?;

        // 2. 聚合组织维度
        self.aggregate_dimension("org", time_range).await?;

        Ok(())
    }

    async fn aggregate_dimension(&self, dimension_type: &str, time_range: TimeRange) -> Result<()> {
        let sql = match dimension_type {
            "room" => self.build_room_aggregation_sql(time_range),
            "org" => self.build_org_aggregation_sql(time_range),
            _ => return Err(Error::InvalidDimension),
        };

        self.stats_repo.execute_aggregation(sql).await
    }

    fn build_org_aggregation_sql(&self, time_range: TimeRange) -> String {
        r#"
        INSERT INTO stats_aggregated (dimension_type, dimension_id, time_bucket, granularity, ...)
        SELECT
            'org'::TEXT AS dimension_type,
            o.id AS dimension_id,
            date_trunc('hour', p.timestamp) AS time_bucket,
            'Hour'::time_granularity AS granularity,
            MAX(online_count) AS peak_online_count,
            AVG(online_count) AS avg_online_count,
            -- ... 其他聚合指标
        FROM presence_events p
        JOIN organizations o ON p.org_path <@ o.path  -- ltree的祖先匹配
        WHERE p.timestamp >= $1 AND p.timestamp < $2 AND p.org_path IS NOT NULL
        GROUP BY o.id, time_bucket
        ON CONFLICT (dimension_type, dimension_id, time_bucket, granularity) DO UPDATE SET
            peak_online_count = GREATEST(stats_aggregated.peak_online_count, EXCLUDED.peak_online_count),
            ...
        "#.to_string()
    }
}
```

**设计改进**:
1. **统一逻辑**: 一个聚合服务，处理所有维度
2. **消除重复**: 不再需要两套相似的聚合代码
3. **易于扩展**: 增加新维度只需添加新的 SQL 构建方法

### 5.2 `StatsService` (统一查询服务)

```rust
pub struct StatsService {
    stats_repo: Arc<dyn StatsRepository>,
}

impl StatsService {
    /// 统一的查询接口，按维度查询统计数据
    pub async fn get_stats(
        &self,
        dimension: Dimension,
        time_range: TimeRange,
        granularity: Granularity,
    ) -> Result<Vec<StatsData>> {
        match dimension {
            Dimension::Room(room_id) => {
                self.stats_repo.find_by_dimension("room", room_id, time_range, granularity).await
            }
            Dimension::Org(org_id) => {
                self.stats_repo.find_by_dimension("org", org_id, time_range, granularity).await
            }
            Dimension::User(user_id) => {
                self.stats_repo.find_by_dimension("user", user_id, time_range, granularity).await
            }
        }
    }
}

pub enum Dimension {
    Room(Uuid),
    Org(Uuid),
    User(Uuid),
}
```

**设计改进**:
1. **统一查询**: 一个服务接口处理所有维度
2. **类型安全**: 使用枚举明确维度类型
3. **代码复用**: Repository 层只需一个查询方法

---

## 6. API设计

### 6.1 组织管理API (`/api/admin/orgs`)

- `POST /`: 创建组织
- `GET /:org_id/tree`: 查询组织树
- `GET /`: 查询组织列表
- `PATCH /:org_id`: 更新组织
- `POST /:org_id/move`: 移动组织
- `DELETE /:org_id`: 删除组织

### 6.2 批量用户管理API (`/api/admin/users`, `/api/admin/tasks`)

- `POST /users/bulk-create`: 提交批量创建任务
- `GET /tasks/:task_id`: 查询任务状态
- `GET /tasks/:task_id/download`: 下载用户凭证

### 6.3 组织统计API (`/api/admin/stats`)

- `GET /stats/:dimension_type/:dimension_id`: 统一查询接口
  - `dimension_type`: 'room' | 'org' | 'user'
  - `dimension_id`: 对应维度的ID
  - 查询参数: `start_time`, `end_time`, `granularity`
- `GET /orgs/:org_id/realtime`: 查询组织实时在线 (通过 Redis 查询)

---

## 7. 实现计划

### 7.1 Phase 1: 数据库层 (0.5天)

- [ ] 创建并应用简化的迁移文件 `0005` (organizations，无冗余字段)
- [ ] 创建并应用 `0006` (users，仅org_id)
- [ ] 创建并应用 `0007-0009` (rooms, presence_events, bulk_tasks)
- [ ] **创建并应用 `0010` (统一维度表 stats_aggregated_v2)**
- [ ] 验证所有表和索引都已正确创建

### 7.2 Phase 2: Domain层 (0.5天)

- [ ] 实现简化的 `Organization` 实体 (统一构造函数)
- [ ] 实现 `OrgPath` 值对象的派生方法 (level, parent)
- [ ] 简化 `User` 实体 (仅 org_id)
- [ ] 编写单元测试

### 7.3 Phase 3: Application层 (1天)

- [ ] 实现 `PgOrgRepository` (处理简化后的schema)
- [ ] **重构 `StatsAggregator`**: 统一处理所有维度的聚合
- [ ] **实现 `StatsService`**: 统一查询接口，支持多维度
- [ ] 修改 `BulkUserService`，在用户连接时写入 org_path 到 presence_events
- [ ] 编写集成测试

### 7.4 Phase 4: API层 (0.5天)

- [ ] 实现组织管理API
- [ ] 实现批量用户管理API
- [ ] **实现统一的统计查询API** (`GET /stats/:type/:id`)
- [ ] 编写API测试

### 7.5 Phase 5: 集成和优化 (0.5天)

- [ ] 端到端测试
- [ ] 性能测试（验证JOIN性能 vs 冗余字段）
- [ ] Code Review

**预计总工期: 3天** (比原方案减少1.5天，因为消除了冗余和重复代码)

---

## 8. 风险与限制

### 8.1 已知限制

- **批量创建性能**: 10万用户约需2分钟，期间数据库写入压力较大。
- **统计延迟**: 分钟级聚合，不是实时数据。
- **JOIN查询性能**: 移除 User.org_path 后，需要通过索引优化JOIN查询。

### 8.2 **已消除的重大风险**

- **数据库锁死风险**: ✅ 已通过创建新表而非修改核心大表的方式完全消除。
- **核心功能污染**: ✅ 已通过统一维度表，避免了表结构重复和代码复杂度。
- **数据不一致风险**: ✅ 通过移除冗余字段，消除了组织重命名时的级联更新问题。
- **维护成本风险**: ✅ 通过统一聚合逻辑，减少了代码维护负担。

### 8.3 性能验证计划

由于移除了 User.org_path 冗余，需要验证 JOIN 查询性能：

```sql
-- 关键查询1: 查询用户所属组织
EXPLAIN ANALYZE
SELECT u.*, o.path as org_path
FROM users u
LEFT JOIN organizations o ON u.org_id = o.id
WHERE u.id = $1;

-- 关键查询2: 查询组织下的所有用户
EXPLAIN ANALYZE
SELECT u.*
FROM users u
JOIN organizations o ON u.org_id = o.id
WHERE o.path <@ 'root.sales';
```

**性能目标**:
- 单用户查询: < 5ms (有 users.org_id 索引)
- 组织用户查询: < 50ms (有 ltree GIST 索引)

如果无法满足，考虑：
1. 增加 materialized view
2. 使用 Redis 缓存热点查询
3. **最后才考虑**恢复 org_path 冗余列（需要配套的数据一致性保障机制）

---

## 9. 后续扩展

- 组织管理员角色。
- 用户批量编辑/停用/删除。
- 统计报表导出。

---

## 10. 附录

### 10.1 重构总结

本次重构基于 Linus Torvalds 的设计哲学，实现了以下改进：

#### 消除的冗余和特殊情况

1. **Organizations表**: 移除 `parent_id` 和 `level`
   - 前: 3个字段存储树形信息，需要CHECK约束保证一致性
   - 后: 1个 `path` 字段，所有信息从此派生
   - 收益: 消除了"根节点 vs 子节点"的特殊情况

2. **User表**: 移除 `org_path` 冗余
   - 前: 同时存储 org_id 和 org_path，组织重命名需要级联更新10万用户
   - 后: 只存储 org_id，通过JOIN查询 org_path
   - 收益: 数据一致性得到保证，避免级联更新

3. **聚合表**: 统一 stats_aggregated 和 org_stats_aggregated
   - 前: 两张schema 99%相同的表，两套重复的聚合代码
   - 后: 一张表 + dimension_type 列，一套统一的聚合逻辑
   - 收益: 代码复杂度减半，未来扩展无需新表

#### 简化的代码

- `Organization::new()` 替代 `new_root()` + `new_child()`
- `StatsAggregator` 统一处理所有维度
- `StatsService` 提供统一查询接口

#### 量化收益

- **代码行数**: 预计减少 30%
- **维护成本**: 减半（一套逻辑 vs 两套重复逻辑）
- **开发时间**: 3天 vs 原方案的 4.5天
- **Bug风险**: 显著降低（消除了数据不一致风险）

### 10.2 `ltree` 核心查询示例

这是 `StatsAggregator` 中组织聚合的核心SQL，展示了ltree的强大之处：

```sql
-- 将所有子部门的事件，聚合到其所有父部门上
-- 这条SQL一次性完成了所有层级的聚合
INSERT INTO stats_aggregated (dimension_type, dimension_id, time_bucket, granularity, peak_online_count, ...)
SELECT
    'org'::TEXT AS dimension_type,
    o.id AS dimension_id,
    date_trunc('hour', p.timestamp) AS time_bucket,
    'Hour'::time_granularity AS granularity,
    MAX(online_count) AS peak_online_count,
    AVG(online_count) AS avg_online_count,
    COUNT(DISTINCT user_id) AS unique_users
    -- ... 其他聚合指标
FROM
    presence_events p
JOIN
    organizations o ON p.org_path <@ o.path  -- 关键：ltree祖先匹配操作符
WHERE
    p.timestamp >= $1 AND p.timestamp < $2 AND p.org_path IS NOT NULL
GROUP BY
    o.id, time_bucket
ON CONFLICT (dimension_type, dimension_id, time_bucket, granularity) DO UPDATE SET
    peak_online_count = GREATEST(stats_aggregated.peak_online_count, EXCLUDED.peak_online_count),
    avg_online_count = EXCLUDED.avg_online_count,
    total_connections = stats_aggregated.total_connections + EXCLUDED.total_connections,
    unique_users = EXCLUDED.unique_users,
    avg_session_duration = EXCLUDED.avg_session_duration;
```

**ltree的魔法**: `p.org_path <@ o.path`

- 如果 presence_event 的 org_path 是 'root.sales.east'
- 这条事件会匹配到三个组织: 'root', 'root.sales', 'root.sales.east'
- 一次JOIN，完成所有层级的聚合
- GIST索引确保查询性能

### 10.3 设计哲学对照

| 原设计 | 重构后 | Linus评语 |
|--------|--------|----------|
| Organizations有parent_id和level | 只有path | "这是好品味。消除了特殊情况。" |
| User存储org_path冗余 | 只存org_id，JOIN查询 | "数据结构对了，代码就对了。" |
| 两张聚合表 | 一张多维度表 | "这不是独立的事，是重复代码。" |
| new_root() vs new_child() | 统一的new() | "10行变成4行的经典案例。" |
| 4.5天工期 | 3天工期 | "简单的代码写得更快。" |
